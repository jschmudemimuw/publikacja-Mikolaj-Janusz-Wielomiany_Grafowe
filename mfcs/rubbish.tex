By definition, if $G_1,G_2$ are graphs (without sources) then 
        \begin{align}
            G_1 \sim G_2 \qquad \text{iff} \qquad \varphi_{\bullet,\bullet}(G_1) = \varphi_{\bullet,\bullet}(G_2).
        \end{align}


        It is enough to prove the special case of the lemma where $\Aa$ is deterministic. Indeed, consider a deterministic automaton, which inputs a run of $\Aa$ and produces the corresponding output. By applying the special case of the lemma for this deterministic automaton, and using nondeterminism to guess the input run, we recover the general case.  Therefore, from now on we assume that $\Aa$ is deterministic. 
        Let $\Aa$ be a deterministic \treetotreewidth{k} register transducer, with registers $R$. For  a register $r \in R$, define $\Aa_r$ to be the register transducer that is obtained from $\Aa$ by setting $r$ to be the output register. We will define a deterministic tree-to-$\aalg$ register transducer $\Bb$ with registers 
        \begin{align*}
        R \times \set{1,\ldots,k,\bullet}^2
        \end{align*}
        such that the following diagram commutes for every $i,j \in \set{1,\ldots,k,\bullet}$:
        \begin{align*}
            \xymatrix@C=4cm{
                \trees \Sigma   
                \ar[dr]^{\Bb_{(r,i,j)}}
                \ar[d]_{\Aa_r} \\
                \txt{graphs of\\
                treewidth $\le k$} \ar[r]_{\varphi_{i,j}}& \aalg
            }
            \end{align*}
    This will prove the lemma, by taking the special case of $r$ being the output register of $\Aa$ and $i=j=\bullet$. 

    
        registers $k$. 
    Denote set of source nodes by $\sources(G)$ and set of nonsource nodes by $\bullet$. Define $\varphi$ to map a sourced graph $G$ to a following ''split'' of walk series, namely a tuple of power series
    $$
    	\varphi: G \longmapsto (g_{i,j})_{i,j \in \allv{G}},
    $$
    where $g_{i,j}$ is the power series of set of walks from $i$ to $j$ of positive length and whose interiors do not touch sources (if $j=\bullet$ we take the set of such walks from $i$ to any nonsource node). More precisely, $g_{i,j} = \sum_{n=1}^{\infty} a_n x^n$, where $a_n$ is the number of such walks of length $n$. Note that a particular $g_{i,j}$ is defined only if all sources among $\{i,j\}$ are defined in $G$. A graph without sources is mapped to $g_{\bullet, \bullet}$ and hence for graphs without sources $G, H$ we have $\varphi(G) = \varphi(H)$ if and only if $G \sim H$.
    
    Now let us investigate how $\varphi(\forget_k(G))$ and $\varphi(\join(G, H))$ can be reconstructed from $\varphi(G), \varphi(H)$.
    Observe that:
    \begin{align}\label{eq:equationForForget}
    	\forget_k(G)_{i,j} &= g_{i,j} + g_{i,k}\cdot(1 + g_{k,k}^+)\cdot g_{k_j},\\
    	\join(G, H)_{i,j} &= g_{i,j} + h_{i,j} \ (- x \text{ if there is an edge } i\text{--}j \text{ in both } G \text{ and } H)
    	\label{eq:equationForJoin}
    \end{align}
    The substraction of $x$ in second equation serves for not counting length-1 walk $i$--$j$ twice, in case it exists both in $G$ and $H$.
    
    Above equations can be written in a form that is more suitable for the rest of the proof:
    \begin{align}
    	\label{eq:interpretationInAfirst}%\tag{\ref*{firsteq}${}^\prime$}
   		\varphi(\forget_k(G)) &= (\varphi(G)_{i,j} + \varphi(G)_{i,k}\cdot(1 + \varphi(G)_{k,k}^+)\cdot \varphi(G)_{k_j})_{i,j \in \allv{G}}, \tag{\ref*{eq:equationForForget}${}^\prime$}\\
    	\varphi(\join(G, H)) &= (\varphi(G)_{i,j} + \varphi(H)_{i,j},
    	\label{eq:interpretationInAlast} \tag{\ref*{eq:equationForJoin}${}^\prime$}
    \end{align}
    equation \eqref{eq:interpretationInAlast} having the same constraint as \eqref{eq:equationForJoin}.
    The above equations hold, just as in ''DFA to regular expression'' proof, as they are substitutions ($x$ for each edge) of equalities that hold for sets of walks.
    
	Let us now construct transducer $\Bb$, which, informally speaking, is an interpretation of $\Aa$ via equations \eqref{eq:interpretationInAfirst}-\eqref{eq:interpretationInAlast}:
	\begin{itemize}
		\item for each register $R$ of $\Aa$ create a tuple of registers $(R_{i,j})_{i, j \in \allv{G}}$,
		\item for each initial register valuation $\rho \in A_k^{\Registers}$ create initial register valuation $(R_{i,j})_{i,j\in\allv{G}} := \varphi(\rho)$,
		\item for each input letter $a$ of arity $n$, for each register update $p = (R:= p_R(\Registers^n) \text{ for } R \in \Registers)$ create a register update $\varphi\circ p$, defined as $((R_{i,j})_{i,j} := \varphi(p_R(\Registers^n)) \text{ for } R\in\Registers)$ where each function $\varphi\circ p_R$ is realized by a terms over $A_k$ obtained from $p_R$ using equations \eqref{eq:interpretationInAfirst}-\eqref{eq:interpretationInAlast}.
	\end{itemize}
	A final remark is that $\Bb$, due to constraint in \eqref{eq:equationForJoin}, also needs to keep information about edges between sources of graphs stored in registers. This however is finite information and can be stored in states (and easily updated). States can be later removed, as observed in the beginning of Section \ref{sec:register-transducers}.