\section{Register transducers}
To approach the equivalence problem for graph-to-graph transductions, we will use tree-to-graph transformations which are defined by extensions of bottom-up tree automata.The idea is that the input trees represent tree decompositions, while elements of the output algebra are algebraic objects that represent the output graphs (e.g.~certain graph polynomials, or certain generating functions). 

In this paper, when transducers input trees, then these trees are  ranked trees over a ranked alphabet, as described below. A \emph{ranked alphabet} is defined to be  a set, where every element has an associated arity. Using a ranked alphabet, one can build trees, as explained in the following picture:
\mypic{4}
We use standard tree terminology, such as descendant, ancestor or parent. When talking about trees, we mean the ranked trees described above, and not acyclic graphs (which are the same as graphs of treewidth 1). 

We now describe the transducer model that will be used in the paper. The idea is that the transducer processes an input tree bottom-up, and uses register to stores elements of some output algebra.  This idea has its roots in the synthesized attributes of attribute grammars of Knuth~\cite{Knuth:1968aa}, and can also be found in the cost register automata of Alur et al.~\cite[p.~15]{alurDantoniDeshmukhYuan2013}. Our definition is based on  terminology of universal algebra that was discussed in Section~\ref{sec:treewidth-definition}.
For a short definition, we omit states from the model.  States would make some constructions easier, but they do not add expressive power, because they  can be simulated using extra registers.

% Define a \emph{polynomial operation of input arity $k$ and output arity $n$} to be any function of type  $A^k \to A^n$, which is given by a $n$ polynomial operations of type $A^k \to A$.
\begin{definition}[Register transducer] Let $\aalg$ be an algebra. The syntax of a  \emph{nondeterministic tree-to-$\aalg$ register transducer} consists of:
    \begin{enumerate}
        \item an input alphabet $\Sigma$, which is a finite ranked set;
        \item a number of registers $k \in \set{1,2,\ldots}$;
        \item for every letter $a \in \Sigma$ of the input alphabet, of arity $n \in \set{0,1,\ldots}$, a finite set of  associated \emph{register updates}, which are  term operations of type  $\aalg^{nk} \to \aalg^k$. 
    \end{enumerate}
    If for each input letter there is exactly one associated register update, then the register transducer is called deterministic. 
\end{definition}
% There is a natural extension of the above model with states, which we call \emph{stateful register transducers}. Stateless and stateful register transducers compute the same functions, but the stateful model is  useful when considering the single-use restriction that will be discussed later in this section. 


A nondeterministic register transducer computes a binary relation, which consists of pairs (tree in $\trees \Sigma$, element of the algebra $\aalg$). Pairs in this relation are obtained by  executing the register updates on the input tree in a bottom-up way, and then returning the value of the first register. Here is a more detailed explanation.  For an input  tree $t \in \trees \Sigma$, define a \emph{reachable register valuation} on $t$ to be any tuple in $\aalg^k$ that  can be obtained in the following, defined by  induction on the size of the tree $t$. Consider a tree which has root label $a$ and child subtrees $t_1,\ldots,t_n$. The induction base of the construction is when $a$ has arity $n=0$ and there are no child subtrees. Let $v_1,\ldots,v_n \in \aalg^k$ be  register valuations that are reachable, respectively,  for the child subtrees, as defined by induction assumption. Concatenate these register valuation into a tuple $\aalg^{nk}$, and apply to this tuple any register update corresponding to $a$. The resulting $k$-tuple is reachable from for the tree $t$. The binary relation computed by a register transducer consists of pairs $(t,\text{first coordinate of some reachable register valuation})$. If the register transducer is deterministic, then the binary relation is a function. 

\begin{example}
    Consider the  Boolean algebra
    \begin{align*}
    \aalg = (\set{0,1},\lor, \land, \neg, 0, 1).
    \end{align*}
    In this case, a valuation of the registers can be seen as a state from a finite set. Also, every operation on states can be described  by a term in the Boolean algebra. Therefore, tree-to-$\aalg$ register transducers are the same thing as the classical model of nondeterministic bottom-up tree automata, which define exactly the regular languages~\cite{}. 
\end{example}

For register transducers, we will study the functionality and equivalence problems. If an algebra $\aalg$ is fixed, then the functionality problem is defined as follows.
\decisionproblem{functionality for nondeterministic tree-to-$\aalg$ register transducers.}{a nondeterministic tree-to-$\aalg$ register transducer.}{is the transducer functional, i.e.~for every input there is exactly one output?}
The equivalence problem is defined similarly, except that the input is two deterministic register transducers, and the question is whether or not they produce equal outputs for all inputs. By the same reasoning as in Fact~\ref{fact:equi-decidable}, we get the following.
\begin{fact}
    For every algebra $\aalg$, the functionality and equivalence problems are equi-decidable.
\end{fact}

\begin{example} In~\cite{seidlManethKemper2018}, Maneth, Seidl and Kemper study  the equivalence problem for  deterministic tree-to-$\aalg$ transducers,  where  the algebra $\aalg$ consists of strings over a finite alphabet, equipped with string concatenation.  Using Hilbert's Basis Theorem, checking equivalence of tree-to-string transducers is shown decidable~\cite[Corollary 8.2]{seidlManethKemper2018}. We will use the same method in this paper.
\end{example}


\smallparagraph{Connection with graph-to-graph transductions} We now show how register transducers can be used to compute functional graph-to-graph \mso transductions of bounded treewidth. We take different approaches to handling the input and output graphs, as described below.
\begin{itemize}
    \item \emph{Input graphs.} The input graphs are represented by tree decompositions. A tree decomposition of width $\ell \in \set{1,2,\ldots}$ can be seen as a tree, where the ranked alphabet is the operations of the algebra of $\ell$-sourced graphs.  Therefore, it makes sense to talk about a register transducer that inputs tree decompositions of width $\ell$. 
    \item \emph{Output graphs.} The output graphs are computed using the algebra of $k$-sourced graphs, for some $k \in \set{1,2,\ldots}$. We assume that the output graphs do not use sources, i.e.~the register transducer is designed so that the output register always stores are $k$-sourced graph where all sources are undefined, i.e.~a graph.
\end{itemize}

A device as described above is a special case of what we call a \emph{\treetotreewidth k register transducer}, i.e.~a register transducer where the algebra is the algebra of $k$-sourced graphs.  

\begin{lemma}\label{lem:transduction-to-registers}
    Let $\ell, k \in \set{1,2,\ldots}$, and  let $\Tt$ be an \mso transduction where all output graphs have treewidth at most $k$. There is a nondeterministic \treetotreewidth{ k} transducer $\Aa$ which makes the following diagram commute (arrows in the diagram are binary relations):
    \begin{align*}
    \xymatrix@C=3cm{
        \txt{tree decompositions\\ of width $\le \ell$}
        \ar[d]_{\txt{\scriptsize underlying graph}}
         \ar[dr]^\Aa\\
        \txt{graphs of\\ treewidth $\le \ell$}\ar[r]_\Tt &
        \txt{graphs  of\\ treewidth $\le k$} 
    }
    \end{align*}
\end{lemma}
The proof of the above lemma uses ideas from~\cite{courcelleMonadicSecondorderLogic1990,bloem_comparison_2000,alurStreamingTreeTransducers2017}, and  is relegated to the appendix.   A corollary of the above lemma is that  equivalence and functionality  problems for graph-to-graph \mso transductions of bounded treewidth  reduce to functionality the functionality problem  for tree-to-$\aalg$, where $\aalg$ is the algebra of $k$-sourced graphs.


